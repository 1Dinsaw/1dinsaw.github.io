<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cat Battle Game</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r146/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>
  <script>
    // Scene, Camera, Renderer
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(10, 10, 10);
    scene.add(directionalLight);

    // Ground Platform
    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(100, 100),
      new THREE.MeshStandardMaterial({ color: 0x654321 })
    );
    ground.rotation.x = -Math.PI / 2; // Lay flat
    scene.add(ground);

    // Cat Player
    const catBody = new THREE.Mesh(
      new THREE.SphereGeometry(1, 32, 32), // Cat body
      new THREE.MeshStandardMaterial({ color: 0xffa500 })
    );
    catBody.position.y = 1;

    const catHead = new THREE.Mesh(
      new THREE.SphereGeometry(0.6, 32, 32), // Cat head
      new THREE.MeshStandardMaterial({ color: 0xffa500 })
    );
    catHead.position.y = 1.8;
    catBody.add(catHead);

    // Sword
    const sword = new THREE.Mesh(
      new THREE.BoxGeometry(0.1, 1, 0.1), // Simple rectangular sword
      new THREE.MeshStandardMaterial({ color: 0xaaaaaa })
    );
    sword.position.set(0.8, 1.2, 0); // Offset to the right hand
    sword.rotation.z = -Math.PI / 4; // Angle slightly backward
    catBody.add(sword);
    scene.add(catBody);

    // GLTF World Loader
    const loader = new THREE.GLTFLoader();
    let world; // Holds the world model
    loader.load(
      'assets/spatial_surfsierp01_pano360_skybox.glb', // Path to the .glb file
      (gltf) => {
        world = gltf.scene;
        world.scale.set(10, 10, 10);
        scene.add(world);
        randomSpawn();
      },
      undefined,
      (error) => {
        console.error('Error loading world:', error);

        // Fallback: Add placeholder world if loading fails
        const placeholderWorld = new THREE.Mesh(
          new THREE.BoxGeometry(50, 50, 50),
          new THREE.MeshStandardMaterial({ color: 0x88ccff })
        );
        placeholderWorld.position.y = 25;
        scene.add(placeholderWorld);
      }
    );

    // Random Spawn Function (for GLTF world)
    function randomSpawn() {
      if (!world) return;
      const boundingBox = new THREE.Box3().setFromObject(world);
      const min = boundingBox.min;
      const max = boundingBox.max;

      const randomX = THREE.MathUtils.randFloat(min.x, max.x);
      const randomZ = THREE.MathUtils.randFloat(min.z, max.z);

      // Use raycasting to find the ground level
      const raycaster = new THREE.Raycaster();
      raycaster.set(new THREE.Vector3(randomX, max.y + 10, randomZ), new THREE.Vector3(0, -1, 0));
      const intersects = raycaster.intersectObject(world, true);
      if (intersects.length > 0) {
        const point = intersects[0].point;
        catBody.position.set(point.x, point.y + 1, point.z);
      }
    }

    // Movement Controls
    const keys = {};
    document.addEventListener('keydown', (e) => keys[e.code] = true);
    document.addEventListener('keyup', (e) => keys[e.code] = false);

    const speed = 0.2;
    function handleMovement() {
      const direction = new THREE.Vector3();
      if (keys['KeyW']) direction.z -= 1;
      if (keys['KeyS']) direction.z += 1;
      if (keys['KeyA']) direction.x -= 1;
      if (keys['KeyD']) direction.x += 1;

      direction.normalize(); // Avoid faster diagonal movement
      catBody.position.addScaledVector(direction, speed);

      // Keep camera focused on the player
      camera.position.set(catBody.position.x, catBody.position.y + 3, catBody.position.z + 5);
      camera.lookAt(catBody.position);
    }

    // Sword Attack Animation
    let swordSwinging = false;
    document.addEventListener('click', () => {
      if (!swordSwinging) {
        swordSwinging = true;
        const swingSpeed = 0.2; // Control how fast the sword swings
        const initialRotation = sword.rotation.z;
        const targetRotation = initialRotation + Math.PI / 2; // Swing forward

        function swingSword() {
          sword.rotation.z += swingSpeed;
          if (sword.rotation.z >= targetRotation) {
            sword.rotation.z = initialRotation; // Reset sword position
            swordSwinging = false;
          } else {
            requestAnimationFrame(swingSword);
          }
        }
        swingSword();
      }
    });

    // Enemy Cat
    const enemy = new THREE.Mesh(
      new THREE.SphereGeometry(1, 32, 32), // Enemy body
      new THREE.MeshStandardMaterial({ color: 0xff0000 }) // Red to distinguish from player
    );
    enemy.position.set(10, 1, 10); // Start at a fixed position
    scene.add(enemy);

    let enemyAlive = true; // Track if the enemy is alive

    // Enemy Movement: Moves towards the player
    function moveEnemy() {
      if (!enemyAlive) return;

      const direction = new THREE.Vector3().subVectors(catBody.position, enemy.position).normalize();
      const speed = 0.05; // Enemy speed
      enemy.position.addScaledVector(direction, speed);

      // Prevent enemy from sinking into the ground
      const raycaster = new THREE.Raycaster();
      raycaster.set(enemy.position.clone().add(new THREE.Vector3(0, 10, 0)), new THREE.Vector3(0, -1, 0));
      const intersects = raycaster.intersectObject(ground, true);
      if (intersects.length > 0) {
        enemy.position.y = intersects[0].point.y + 1;
      }
    }

    // Sword Collision Detection
    function checkSwordCollision() {
      if (!enemyAlive) return;

      // Create bounding boxes for the sword and enemy
      const swordBox = new THREE.Box3().setFromObject(sword);
      const enemyBox = new THREE.Box3().setFromObject(enemy);

      if (swordBox.intersectsBox(enemyBox)) {
        // If sword hits the enemy
        scene.remove(enemy);
        enemyAlive = false;
        console.log("Enemy defeated!");
      }
    }

    // Handle Window Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Game Loop
    function animate() {
      requestAnimationFrame(animate);

      handleMovement(); // Player movement
      moveEnemy(); // Enemy movement
      checkSwordCollision(); // Check for attacks

      renderer.render(scene, camera);
    }
    animate();
  </script>
</body>
</html>